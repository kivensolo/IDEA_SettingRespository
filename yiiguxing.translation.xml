<application>
  <component name="Translation.Cache">
    <option name="lastTrimTime" value="1691717022669" />
  </component>
  <component name="Translation.Settings">
    <option name="primaryLanguage" value="AUTO" />
    <option name="translator" value="YOUDAO" />
    <option name="wordbookStoragePath" value="C:\Users\ZekeWang\OneDrive\TranslationPlugin" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="6953e2b0635b37a0" />
      </youdao-translate>
    </option>
  </component>
  <component name="Translation.States">
    <option name="newTranslationDialogWidth" value="592" />
    <option name="newTranslationDialogX" value="2711" />
    <option name="newTranslationDialogY" value="456" />
    <histories>
      <item value="Note that {@code PsiFile} passed to handler's methods isn't guaranteed to be in sync with the document at the time of invocation (due to performance considerations). {@link com.intellij.psi.PsiDocumentManagercommitDocument(Document)} should be invoked explicitly, if an up-to-date PSI is required." />
      <item value="Handler, extending IDE behaviour on typing in editor." />
      <item value="Called after the specified character typed by the user has been inserted in the editor." />
      <item value="Extension points defined by the plugin" />
      <item value="Make the document change in the context of a write action." />
      <item value="This is a custom {@link TypedHandlerDelegate} that handles actions activated keystrokes in the editor. The execute method inserts a fixed string at Offset 0 of the document. Document changes are made in the context of a write action." />
      <item value="May support several carets existing simultaneously in a document. {@link supportsMultipleCarets()} method can be used to find out whether particular instance of CaretModel does it. If it does, query and update methods for caret position operate on a certain 'primary' caret." />
      <item value="If it does, query and update methods for caret position operate on a certain 'primary' caret." />
      <item value="How 'primary' caret is determined by the model is not defined (currently it's the most recently added caret, but that can change)." />
      <item value="Update methods, {@link runBatchCaretOperation(Runnable)} and {@link runForEachCaret(CaretAction)} methods should only be run from EDT. Query methods can be run from any thread, when called not from EDT, those methods are 'not aware' of 'runForEachCaret' scope - they will always return information about primary caret." />
      <item value="run Batch Caret Operation" />
      <item value="At all times at least one caret will exist in a document." />
      <item value="May support several carets existing simultaneously in a document." />
      <item value="May support several carets existing simultaneously in a document. {@link supportsMultipleCarets()} method can be used to find out whether particular instance of CaretModel does it. If it does, query and update methods for caret position operate on a certain 'primary' caret. There exists a way to perform the same operation(s) on each caret - see {@link runForEachCaret(CaretAction)} method. Within its context, query and update methods operate on the current caret in that iteration. This behaviour can change in future though, so using caret and selection query and update methods in actions that need to operate on multiple carets is discouraged - methods on {@link Caret} instances obtained via {@link getAllCarets()} or {@link runForEachCaret(CaretAction)} should be used instead. &lt;p&gt; How 'primary' caret is determined by the model is not defined (currently it's the most recently added caret, but that can change). &lt;p&gt; At all times at least one caret will exist in a document. &lt;p&gt; Update methods, {@link runBatchCaretOperation(Runnable)} and {@link runForEachCaret(CaretAction)} methods should only be run from EDT. Query methods can be run from any thread, when called not from EDT, those methods are 'not aware' of 'runForEachCaret' scope - they will always return information about primary caret." />
      <item value="Provides services for moving the caret and retrieving information about caret position." />
      <item value="caret" />
      <item value="caret model" />
      <item value="Returns the caret model for the document, which can be used to add and remove carets to the editor, as well as to query and update carets' and corresponding selections' positions." />
      <item value="Caret Model" />
      <item value="If conditions support it, makes a menu visible to display information about the caret." />
      <item value="Could not resolve org.jetbrains.intellij.plugins:gradle-intellij-plugin:1.13.3." />
      <item value="Module Version Resolve Exception" />
      <item value="Incompatible because this component declares documentation and the consumer needed a library" />
      <item value="Incompatible because this component declares a component, compatible with Java 11 and the consumer needed a component, compatible with Java 8" />
      <item value="Editor Add Caret" />
      <item value="Editor Add Care" />
      <item value="Illustration" />
      <item value="CARET" />
      <item value="ACTION EDITOR CLONE CARET BELOW" />
      <item value="Get the action manager in order to get the necessary action handler..." />
      <item value="Clones a new caret at a higher Logical Position line number." />
      <item value="Ensure the list of carets in the editor is not empty" />
      <item value="Make sure at least one caret is available" />
      <item value="Returns not null data by a data key. This method assumes that data has been checked for null in AnActionupdate method" />
      <item value="Container for the information necessary to execute or update an AnAction." />
      <item value="it's always enabled if a project and editor are open" />
      <item value="Place this entry first in the popup menu" />
      <item value="Handler" />
      <item value="Adds a second caret below the existing one" />
      <item value="The same action can have various presentations" />
      <item value="place" />
      <item value="presentation" />
      <item value="you can dynamically change action's presentation" />
      <item value="Represents an entity that has a state, a presentation and can be performed. For an action to be useful, you need to implement actionPerformed and optionally to override update. By overriding the update method you can dynamically change action's presentation depending on the place (for more information on places see ActionPlaces. The same action can have various presentations." />
      <item value="Implement this method to provide your action handler. Params: e â€“ Carries information on the invocation place" />
      <item value="Updates the state of the action. Default implementation does nothing. Override this method to provide the ability to dynamically change action's state and(or) presentation depending on the context (For example when your action state depends on the selection you can check for selection and change the state accordingly).&lt;p&gt;&lt;p&gt; This method can be called frequently, and on UI thread. This means that this method is supposed to work really fast, no real work should be done at this phase. For example, checking selection in a tree or a list, is considered valid, but working with a file system or PSI (especially resolve) is not. If you cannot determine the state of the action fast enough, you should do it in the {@link actionPerformed(AnActionEvent)} method and notify the user that action cannot be executed if it's the case.&lt;p&gt;&lt;p&gt; If the action is added to a toolbar, its &quot;update&quot; can be called twice a second, but only if there was any user activity or a focus transfer. If your action's availability is changed in absence of any of these events, please call {@code ActivityTracker.getInstance().inc()} to notify action subsystem to update all toolbar actions when your subsystem's determines that its actions' visibility might be affected. @param e Carries information on the invocation place and data available" />
      <item value="Editor Illustration Action" />
      <item value="Convert to Gradle-based plugin" />
      <item value="Menu action to clone a new caret based on an existing one." />
      <item value="De-select the text range that was just replaced" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="AFRIKAANS" value="1" />
        <entry key="CHINESE" value="326" />
        <entry key="DANISH" value="1" />
        <entry key="ENGLISH" value="308" />
        <entry key="FRENCH" value="1" />
        <entry key="HINDI" value="1" />
        <entry key="INDONESIAN" value="5" />
        <entry key="ITALIAN" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="POLISH" value="2" />
        <entry key="SUNDANESE" value="1" />
        <entry key="SWEDISH" value="4" />
        <entry key="TURKISH" value="1" />
      </map>
    </option>
  </component>
  <component name="Translation.YoudaoSettings">
    <option name="DOMAIN" value="COMPUTERS" />
  </component>
</application>